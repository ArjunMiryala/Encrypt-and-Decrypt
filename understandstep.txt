ğŸ” What is derive_key()?
Passwords are not secure keys. To use AES-256-GCM, we need a 256-bit (32-byte) key.

So weâ€™ll use scrypt, a password-based key derivation function (PBKDF) that:

is slow by design (to block brute-force attackers),

uses salt (to prevent rainbow table attacks),

outputs a fixed-length binary key.


ğŸ” Step 1: derive_key() â€” Line-by-Line Breakdown
Weâ€™ll write the function first principles style so that nothing feels like magic.

â“ What is this function doing?
We're turning a human password (e.g. "hello123") into a 256-bit cryptographic key. Why?

Because AESâ€‘GCM needs a raw binary key: 32 bytes for AESâ€‘256

We can't use strings directly â€” they're guessable & not binary

So we run it through scrypt, a "slow hash function" for passwords


ğŸ” Step 2: encrypt() â€” Encrypt a File using AES-GCM
ğŸ§  The Big Picture
Hereâ€™s what this function does:

Action	Why it matters
Read the file	We want to encrypt its content.
Generate a random salt	Used to create a unique key from the password.
Derive a secure key	Converts human password into strong 256-bit key.
Generate a random nonce	Prevents attackers from seeing patterns.
Encrypt using AESâ€‘GCM	Authenticated, modern, secure encryption.
Save encrypted data	Into a .pv file with salt/nonce attached.


ğŸ”“ Step 3: decrypt() â€” Reverse AES-GCM and get your original file back
ğŸ§  The Big Picture
We want to:

Open the encrypted file (with .pv extension)

Check if it's really one of our files (via MAGIC header)

Extract:

the salt (used to derive key)

the nonce (used during encryption)

the ciphertext (encrypted file data)

Rebuild the key using the salt and password

Decrypt the ciphertext using AES-GCM

Write the decrypted file back to disk

**data in the encryot funtion is turned into cyoher text so e=when de crypting it we use use it in the decrypt method 
data = aesgcm.decrypt(nonce, ciphertext, None)

**